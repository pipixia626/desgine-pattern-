# 创建模式

## 工厂模式
适合大量的产品需要创建，并且这些产品具有共同的接口
### 简单工厂模式
定义了一个创建对象的类，由这个类来封装实例化对象的行为
#### 产生问题与解决办法
类的创建依赖工厂类，如果想要拓展程序，必须对工厂类进行修改，这违背了开闭原则

定义一个创建对象的抽象方法并创建多个不同的工厂类实现
### 工厂方法模式
定义了一个创建对象的抽象方法，由子类决定要实例化的类，工厂方法模式将对象的实例化推到了子类
#### 产生问题与解决办法
客户端需要创建类的具体的实例
简单来说用户要订纽约工厂的披萨就必须去纽约工厂，要订伦敦的就必须去伦敦工厂，当这两个工厂发生变化了，用户也要变化

把工厂类抽象为接口，用户只需要去默认的工厂提出自己的需求，便能得到自己想要的产品，而不用根据产品去寻找不同的工厂
### 抽象工厂模式
定义一个接口用于创建相关或有依赖关系的对象族，而无需明确指定具体类

在抽象工厂中只需要传入参数就可以实例化对象


### 三种工厂模式的使用选择
简单工厂 ： 用来生产同一等级结构中的任意产品。（不支持拓展增加产品）

工厂方法 ：用来生产同一等级结构中的固定产品。（支持拓展增加产品）   

抽象工厂 ：用来生产不同产品族的全部产品。（支持拓展增加产品；支持增加产品族）
简单工厂的适用场合：只有伦敦工厂（只有这一个等级），并且这个工厂只生产三种类型的pizza：chesse,pepper,greak（固定产品）。

工厂方法的适用场合：现在不光有伦敦工厂，还增设了纽约工厂（仍然是同一等级结构，但是支持了产品的拓展），这两个工厂依然只生产三种类型的pizza：chesse,pepper,greak（固定产品）。

抽象工厂的适用场合：不光增设了纽约工厂（仍然是同一等级结构，但是支持了产品的拓展），这两个工厂还增加了一种新的类型的pizza：chinese pizza（增加产品族）。

所以说抽象工厂就像工厂，而工厂方法则像是工厂的一种产品生产线。因此，我们可以用抽象工厂模式创建工厂，而用工厂方法模式创建生产线。比如，我们可以使用抽象工厂模式创建伦敦工厂和纽约工厂，使用工厂方法实现cheese pizza和greak pizza的生产

### 总结
简单工厂模式就是建立一个实例化对象的类，在该类中多个对象实例化，
工厂方法模式定义了一个创建对象的抽象方法，由子类决定要实例化的类，这样做的好处是再有新的类型的对象需要实例化，只要增加子类即可。

抽象工厂模式定义了一个接口用于创建对象族，而无需明确具体类，抽象工厂也是把对象的实例化交给了子类，支持扩展

## 单例模式
确保一个类最多只有一个实例，并提供一个全局访问点
### 预加载
还没有使用该单例对象，但是，该单例对象就已经被加载到内存了
可用保证线程安全

### 懒加载 
为了避免内存的浪费，我们可以采用懒加载，即用到该单例对象的时候再创建

不可以保证线程的安全->因为new 单例对象时不满足原子性或者顺序性

## 生成器模式
封装一个复杂对象构造过程，并允许按步骤构造

### 四种角色
1. 产品：具体生产器要构造的复杂对象
2. 抽象生成器(bulider)：是一个接口，该接口除了为创建一个产品对象的各个组件定义若干方法之外，还要定义返回产品对象的方法
3. 具体生成器：实现Bulider接口的类，具体生成器将Buider接口所定义的方法(生产各个组件)
4. 指挥者(director)：指挥者是一个类，该类需要含有Builder接口声明的变量。指挥者的职责是负责向用户提供具体生成器，即指挥者将请求具体生成器类来构造用户所需要的Product对象，如果所请求的具体生成器成功地构造出Product对象，指挥者就可以让该具体生产器返回所构造的Product对象。（按照步骤组装部件，并返回Product）

### 优缺点

- 优点
1. 将一个对象分解为各个组件
2. 将对象组件的构造封装起来
3. 可以控制整个对象的生成过程

- 缺点
1. 对不同类型的对象需要实现不同的具体构造器的类，这可能回答大大增加类的数量

### 与工厂模式的不同
生成器模式构建对象的时候，对象通常构建的过程中需要多个步骤，就像我们例子中的先有主机，再有显示屏，再有鼠标等等，生成器模式的作用就是将这些复杂的构建过程封装起来。工厂模式构建对象的时候通常就只有一个步骤，调用一个工厂方法就可以生成一个对象。

## 原型模式
通过复制现有实例来创建新的实例，无需知道相应类的信息

"clone"
### 浅复制
将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。
### 深复制
将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。clone明显是深复制，clone出来的对象是是不能去影响原型对象的

时间效率的问题
